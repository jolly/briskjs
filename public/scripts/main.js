/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/scripts/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(1);\n__webpack_require__(5);\nmodule.exports = __webpack_require__(7);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stylus-mixins/index.styl\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/stylus-mixins/index.styl?");

/***/ },
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./assets/styles/index.styl\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./assets/styles/index.styl?");

/***/ },
/* 6 */,
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _simplePjax = __webpack_require__(8);\n\nvar _simplePjax2 = _interopRequireDefault(_simplePjax);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n$(document).ready(function () {\n\n  // Place JavaScript code here...\n  console.log('testing');\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./assets/scripts/main.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./assets/scripts/main.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/**\n * Source and documentation:\n *   https://github.com/Mitranim/simple-pjax\n */\n\n!function() {\n'use strict';\n\n// No-op if not running in a browser.\nif (typeof window !== 'object' || !window) return;\n\n// No-op if pushState is unavailable.\nif (typeof history.pushState !== 'function') return;\n\n/* global location, XMLHttpRequest, Location, requestAnimationFrame, cancelAnimationFrame, history, HTMLElement, HTMLScriptElement, HTMLAnchorElement, HTMLDocument, DOMParser, Event, getComputedStyle */\n\n/**\n * Export.\n */\nvar pjax = {\n\n  /**\n   * Configuration.\n   */\n\n  // Disables pjax globally.\n  disabled: false,\n\n  // How long until we run loading indicators.\n  loadIndicatorDelay: 250,\n\n  // Called when loading takes longer than `loadIndicatorDelay`. Should\n  // visibly indicate the loading.\n  onIndicateLoadStart: function onIndicateLoadStart() {\n    document.documentElement.style.transition = 'opacity linear 0.05s';\n    document.documentElement.style.opacity = '0.8';\n  },\n\n  // Called when transition is finished. Should roll back the effects of\n  // `onIndicateLoadStart`.\n  onIndicateLoadEnd: function onIndicateLoadEnd() {\n    document.documentElement.style.transition = '';\n    document.documentElement.style.opacity = '';\n  },\n\n  // If a CSS selector is provided, it's checked every time when scrolling to an\n  // element (e.g. via data-scroll-to-id). If an element with the {position:\n  // 'fixed', top: '0px'} computed style properties is found, the scroll\n  // position will be offset by that element's height.\n  scrollOffsetSelector: '',\n\n  // If a value is provided, it will be used as the default id for the\n  // `[data-scroll-to-id]` attribute.\n  defaultMainId: '',\n\n  /**\n   * Methods.\n   */\n\n  // Triggers a pjax transition to the current page, reloading it without\n  // destroying the JavaScript runtime and other assets.\n  reload: function reload() {\n    transitionTo(new Config(location, {\n      'data-noscroll': true,\n      'data-force-reload': true\n    }));\n  }\n};\n\n// Export in a CommonJS environment, otherwise assign to window.\nif (typeof module === 'object' && module !== null && typeof module.exports === 'object' && module.exports !== null) {\n  module.exports = pjax;\n} else {\n  window.simplePjax = pjax;\n}\n\n// Current request. Only one can be active at a time.\nvar currentXhr = null;\n\n// Used to detect useless popstate events.\nvar lastPathname = '';\nvar lastQuery = '';\nrememberPath();\n\nvar attrNames = ['data-noscroll', 'data-force-reload', 'data-scroll-to-id'];\n\n// Configuration object for interfacing between anchors, `location`, and\n// programmatic triggers.\nfunction Config(urlUtil, attrs) {\n  var _this = this;\n\n  this.href = '';\n  this.host = '';\n  this.hash = '';\n  this.pathname = '';\n  this.path = '';\n  this.protocol = '';\n  this.search = '';\n  this.isPush = false;\n  this.rafId = 0;\n\n  // Copy main attributes.\n  Object.keys(this).forEach(function (key) {\n    if (key in urlUtil) _this[key] = urlUtil[key];\n  });\n\n  // Define path.\n  this.path = this.protocol + '//' + this.host + this.pathname;\n\n  // Copy attributes, if applicable.\n  if (urlUtil instanceof HTMLElement) {\n    attrNames.forEach(function (name) {\n      if (urlUtil.hasAttribute(name)) {\n        _this[name] = urlUtil.getAttribute(name);\n      }\n    });\n  }\n\n  // Add any additionally passed attributes.\n  if (attrs) {\n    Object.keys(attrs).forEach(function (key) {\n      _this[key] = attrs[key];\n    });\n  }\n}\n\n// Main listener.\ndocument.addEventListener('click', function (event) {\n  // No-op if pjax is disabled.\n  if (pjax.disabled) return;\n\n  // Find a clicked <a>. No-op if no anchor is available.\n  var anchor = event.target;\n  do {\n    if (anchor instanceof HTMLAnchorElement) break;\n  } while (anchor = anchor.parentElement);\n  if (!anchor) return;\n\n  // Ignore modified clicks.\n  if (event.button !== 0) return;\n  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return;\n\n  // Ignore links to other sites.\n  if (anchor.protocol + '//' + anchor.host !== location.origin) return;\n\n  // Ignore links intended to affet other tabs or windows.\n  if (anchor.target === '_blank' || anchor.target === '_top') return;\n\n  // Ignore links with the data-no-pjax attribute.\n  if (anchor.hasAttribute('data-no-pjax')) return;\n\n  // Ignore hash links on the same page if `pjax.scrollOffsetSelector` is\n  // unspecified.\n  if (anchor.pathname === location.pathname && anchor.hash && !pjax.scrollOffsetSelector) {\n    return;\n  }\n\n  // Load clicked link.\n  event.preventDefault();\n  transitionTo(new Config(anchor, { isPush: true }));\n});\n\nwindow.addEventListener('popstate', function (event) {\n  // Ignore useless popstate events. This includes initial popstate in Webkit\n  // (not in Blink), and popstate on hash changes. Note that we ignore hash\n  // changes by not remembering or comparing the hash at all.\n  if (pathUnchanged()) return;\n  rememberPath();\n\n  /*\n   * After a popstate event, Blink/Webkit (what about Edge?) restore the\n   * last scroll position the browser remembers for that history entry.\n   * Because our XHR is asynchronous and there's a delay before replacing the\n   * document, this causes the page to jump around. To prevent that, we\n   * artificially readjust the scroll position. If the XHR is finished before\n   * the next frame runs, we cancel the task.\n   *\n   * Webkit (Safari) does receive the correct scroll values, but the page still\n   * jumps around. TODO look for a workaround.\n   *\n   * Unfortunately FF restores the scroll position _before_ firing popstate\n   * (which is spec-compliant), so the page still jumps around. To work around\n   * this, we would have to listen to scroll events on window and continuously\n   * memorize the last scroll position; I'm going to leave the FF behaviour\n   * as-is until a better workaround comes up.\n   *\n   * The FF problem might fix itself:\n   *   https://bugzilla.mozilla.org/show_bug.cgi?id=1186774\n   *   https://github.com/whatwg/html/issues/39\n   */\n\n  var currentX = window.scrollX;\n  var currentY = window.scrollY;\n  var rafId = requestAnimationFrame(function () {\n    window.scrollTo(currentX, currentY);\n  });\n\n  transitionTo(new Config(location, { rafId: rafId }));\n});\n\nfunction transitionTo(config) {\n  // Special behaviour if this is a push transition within one page. If it leads\n  // to a hash target, try to scroll to it. Pjax is not performed.\n  var path = location.protocol + '//' + location.host + location.pathname;\n\n  if (config.isPush && config.path === path && config.search === location.search && !('data-force-reload' in config)) {\n    // Change the URL and history, if applicable. This needs to be done before\n    // changing the scroll position in order to let the browser correctly\n    // remember the current position.\n    if (config.href !== location.href) {\n      history.pushState(null, document.title, config.href);\n      rememberPath();\n    }\n\n    if (config.hash) {\n      // Hash found: try to scroll to it.\n      var target = document.querySelector(config.hash);\n      if (target instanceof HTMLElement) {\n        target.scrollIntoView();\n        offsetScroll();\n      }\n    }\n\n    return;\n  }\n\n  // No-op if a request is currently in progress.\n  if (currentXhr) return;\n\n  var xhr = currentXhr = new XMLHttpRequest();\n\n  xhr.onload = function () {\n    if (xhr.status < 200 || xhr.status > 299) {\n      xhr.onerror(null);\n      return;\n    }\n\n    // Cancel the scroll readjustment, if any. If it has already run, this\n    // should have no effect.\n    if (config.rafId) cancelAnimationFrame(config.rafId);\n\n    currentXhr = null;\n    var newDocument = getDocument(xhr);\n\n    if (!newDocument) {\n      xhr.onerror(null);\n      return;\n    }\n\n    if (config.isPush) {\n      var replacementHref = xhr.responseURL && xhr.responseURL !== config.path ? xhr.responseURL : config.href;\n      history.pushState(null, newDocument.title, replacementHref);\n      rememberPath();\n    }\n\n    /*\n     * Workaround for a Safari glitch. In Safari, if the document has been\n     * scrolled down by the user before the transition, and if it has any\n     * fixed-positioned elements, these elements will jump around for a\n     * moment after completing a pjax transition. This happens if we only\n     * scroll _after_ replacing the document. To avoid this, we basically\n     * have to scroll twice: before and after the transition. This doesn't\n     * eliminate the problem, but makes it less frequent.\n     *\n     * Safari truly is the new IE.\n     */\n\n    var noScroll = ('data-noscroll' in config);\n    var targetId = location.hash ? location.hash.slice(1) : null;\n    if (!targetId && config.isPush && 'data-scroll-to-id' in config) {\n      targetId = config['data-scroll-to-id'] || pjax.defaultMainId;\n    }\n\n    // First scroll: before the transition.\n    var target = document.getElementById(targetId);\n    if (target) {\n      target.scrollIntoView();\n      offsetScroll();\n    } else if (!targetId && !noScroll) {\n      window.scrollTo(0, 0);\n    }\n\n    // Hook for scripts to clean up before the transition.\n    document.dispatchEvent(createEvent('simple-pjax-before-transition'));\n\n    // Switch to the new document.\n    replaceDocument(newDocument);\n    indicateLoadEnd();\n\n    // Provide a hook for scripts that may want to run when the document\n    // is loaded.\n    document.dispatchEvent(createEvent('simple-pjax-after-transition'));\n\n    // Second scroll: after the transition.\n    target = document.getElementById(targetId);\n    if (target) {\n      target.scrollIntoView();\n      offsetScroll();\n    } else if (!noScroll) {\n      window.scrollTo(0, 0);\n    }\n  };\n\n  xhr.onabort = xhr.onerror = xhr.ontimeout = function () {\n    currentXhr = null;\n    if (config.isPush) history.pushState(null, '', xhr.responseURL || config.href);\n    location.reload();\n  };\n\n  xhr.open('GET', config.href);\n  // IE compat: responseType must be set after opening the request.\n  xhr.responseType = 'document';\n  xhr.send(null);\n\n  indicateLoadStart(xhr);\n}\n\nfunction indicateLoadStart(xhr) {\n  if (pjax.loadIndicatorDelay > 0) {\n    (function () {\n      var id = setTimeout(function () {\n        if (xhr.readyState === 4) {\n          clearTimeout(id);\n          return;\n        }\n        if (typeof pjax.onIndicateLoadStart === 'function') {\n          pjax.onIndicateLoadStart();\n        }\n      }, pjax.loadIndicatorDelay);\n    })();\n  }\n}\n\nfunction indicateLoadEnd() {\n  if (pjax.loadIndicatorDelay > 0 && typeof pjax.onIndicateLoadEnd === 'function') {\n    pjax.onIndicateLoadEnd();\n  }\n}\n\n// TODO test in Opera.\nfunction getDocument(xhr) {\n  var type = xhr.getResponseHeader('Content-Type') || 'text/html';\n  // Ignore non-HTML resources, such as XML or plan text.\n  if (!/html/.test(type)) return null;\n  if (xhr.responseXML) return xhr.responseXML;\n  return new DOMParser().parseFromString(xhr.responseText, 'text/html');\n}\n\nfunction replaceDocument(doc) {\n  // Replace the `title` as the only user-visible part of the head. Assume\n  // resource links, `<base>`, and other meaningful metadata to be identical.\n  document.title = doc.title;\n\n  // Remove all scripts from the current `<head>` to ensure consistent state.\n  [].slice.call(document.head.querySelectorAll('script')).forEach(function (script) {\n    script.parentNode.removeChild(script);\n  });\n\n  // Remove all `src` scripts under the assumption that they're the same on all\n  // pages.\n  removeScriptsWithSrc(doc);\n\n  // Replace the body.\n  document.body = doc.body;\n\n  // Execute inline scripts found in the new document. Creating copies and\n  // adding them to the DOM (instead of using `new Function(...)()` to eval)\n  // should allow custom script types to work (TODO test). We leave the original\n  // scripts in the DOM to preserve the behaviour of scripts that target\n  // themselves by `id` to be replaced with a widget (common strategy for iframe\n  // embeds).\n  [].slice.call(document.scripts).forEach(function (script) {\n    document.body.appendChild(copyScript(script));\n  });\n}\n\nfunction removeScriptsWithSrc(doc) {\n  [].slice.call(doc.scripts).forEach(function (script) {\n    if (!!script.src && !!script.parentNode) {\n      script.parentNode.removeChild(script);\n    }\n  });\n}\n\n// Creates an incomplete copy of the given script that inherits only type and\n// content from the original. Other attributes such as `id` are not copied in\n// order to preserve the behaviour of scripts that target themselves by `id` to\n// be replaced with a widget. If the script potentially destroys the document\n// through a `document.write` or `document.open` call, a dummy is returned.\nfunction copyScript(originalScript) {\n  var script = document.createElement('script');\n  if (!destroysDocument(originalScript.textContent)) {\n    if (originalScript.type) script.type = originalScript.type;\n    script.textContent = originalScript.textContent;\n  }\n  return script;\n}\n\n// Very primitive check if the given script contains calls that potentially\n// erase the document's contents.\nfunction destroysDocument(script) {\n  return (/document\\s*\\.\\s*(?:write|open)\\s*\\(/.test(script)\n  );\n}\n\n// Used with each `history.pushState` call to help us discard redundant popstate\n// events.\nfunction rememberPath() {\n  lastPathname = location.pathname;\n  lastQuery = location.search;\n}\n\nfunction pathUnchanged() {\n  return location.pathname === lastPathname && location.search === lastQuery;\n}\n\n// IE compat: IE doesn't support dispatching events created with constructors,\n// at least not for document.dispatchEvent.\nfunction createEvent(name) {\n  var event = document.createEvent('Event');\n  event.initEvent(name, true, true);\n  return event;\n}\n\n// See pjax.scrollOffsetSelector.\nfunction offsetScroll() {\n  if (pjax.scrollOffsetSelector) {\n    var elem = document.querySelector(pjax.scrollOffsetSelector);\n    var style = getComputedStyle(elem);\n    if (style.position === 'fixed' && style.top === '0px') {\n      window.scrollBy(0, -elem.getBoundingClientRect().height);\n    }\n  }\n}\n\n}();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/simple-pjax/dist/simple-pjax.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/simple-pjax/dist/simple-pjax.js?");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }
/******/ ]);